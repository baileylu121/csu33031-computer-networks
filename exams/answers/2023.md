# CSU33031 Computer Networks Exam Answers
## December 2023

---

# Question 1

## Part a) Flow Control [25 marks]

### i) Define the term "flow control" and describe a transfer with and without flow control mechanisms.

**Definition of Flow Control:**
Flow control is a mechanism at the data link layer (and transport layer) that regulates the rate at which a sender transmits data to prevent overwhelming a slower receiver. It ensures that the sender does not transmit frames faster than the receiver can process them, preventing buffer overflow and data loss.

**Transfer WITHOUT Flow Control:**

```
Sender                                    Receiver (slow)
   |                                           |
   |---Frame 1--->                             |
   |---Frame 2--->                             | [Buffer: Frame 1]
   |---Frame 3--->                             | [Buffer: Frame 1, Frame 2]
   |---Frame 4--->                             | [Buffer: FULL! Processing Frame 1]
   |---Frame 5--->                             | 
   |                                           | Frame 4 DROPPED!
   |                                           | Frame 5 DROPPED!
   |                                           |
   |  Sender has no idea frames were lost      |
```

**Problems:** Buffer overflow at receiver, dropped frames, no recovery mechanism, wasted bandwidth, unreliable delivery.

**Transfer WITH Flow Control (Stop-and-Wait example):**

```
Sender                                    Receiver
   |                                           |
   |---Frame 1--->                             |
   |                                           | [Process Frame 1]
   |<---ACK 1-----                             | "Ready for more"
   |                                           |
   |---Frame 2--->                             |
   |                                           | [Process Frame 2]
   |<---ACK 2-----                             |
   |                                           |
   |---Frame 3--->                             |
   |                                           | [Process Frame 3]
   |<---ACK 3-----                             |
```

**Benefits:** Receiver controls pace, no buffer overflow, reliable delivery, sender knows delivery status.

### ii) Stop-and-Wait ARQ and Selective Repeat ARQ Mechanisms

**Given:** 4 bits for sequence numbers → range 0-15 (16 values)

#### Stop-and-Wait ARQ

**Mechanism:**
- Sender transmits one frame, waits for acknowledgement
- Uses alternating sequence numbers (only needs 0 and 1, but can use more)
- Timeout triggers retransmission if ACK not received

**State at Sender:**
- Next sequence number to send
- Copy of last frame sent (for retransmission)
- Timer for timeout

**State at Receiver:**
- Expected sequence number
- Last ACK sent (for duplicate handling)

**Normal Operation:**
```
Sender                                    Receiver
   |        Seq=0                             |
   |---[Frame 0]----->                        |
   |                                          | [Receive, deliver]
   |<----[ACK 0]------                        | Expected: 1
   |                                          |
   |        Seq=1                             |
   |---[Frame 1]----->                        |
   |                                          | [Receive, deliver]
   |<----[ACK 1]------                        | Expected: 2
```

**Error Handling (Frame Corrupted):**
```
Sender                                    Receiver
   |        Seq=0                             |
   |---[Frame 0]---X (corrupted)              |
   |                                          | [FCS fails, discard]
   |    TIMEOUT                               |
   |        Seq=0 (retransmit)                |
   |---[Frame 0]----->                        |
   |                                          | [Receive, deliver]
   |<----[ACK 0]------                        |
```

**Error Handling (ACK Lost):**
```
Sender                                    Receiver
   |---[Frame 0]----->                        |
   |                                          | [Deliver]
   |<----[ACK 0]---X (lost)                   |
   |    TIMEOUT                               |
   |---[Frame 0]----->  (retransmit)          |
   |                                          | [Duplicate! Discard, re-ACK]
   |<----[ACK 0]------                        |
```

**Advantages:**
- Simple implementation
- Minimal state required
- Low memory requirements

**Disadvantages:**
- Very inefficient (utilization = T_frame / (T_frame + 2×T_prop))
- Channel idle during round-trip time
- Poor performance on high bandwidth-delay product links

#### Selective Repeat ARQ

**Mechanism:**
- Sender maintains a window of frames that can be sent without ACK
- Receiver buffers out-of-order frames
- Only corrupted/lost frames are retransmitted

**Window Size Constraint (4-bit sequence numbers):**
- Sender window ≤ 2^(4-1) = 8 frames
- Receiver window ≤ 8 frames
- This prevents ambiguity between new and retransmitted frames

**State at Sender:**
- Send window base (oldest unACKed frame)
- Next sequence number to use
- Buffer of all unACKed frames
- Individual timer for each outstanding frame
- Bitmap of received ACKs

**State at Receiver:**
- Receive window base (next expected in-order frame)
- Buffer for out-of-order frames
- Bitmap of received frames within window

**Normal Operation (Window size = 4):**
```
Sender                                    Receiver
   |                                          |
   |---[Frame 0]----->                        | Deliver 0
   |---[Frame 1]----->                        | Deliver 1
   |---[Frame 2]----->                        | Deliver 2
   |---[Frame 3]----->                        | Deliver 3
   |                 (window full, wait)      |
   |<----[ACK 0,1,2,3]--                      |
   |                                          |
   |---[Frame 4]----->                        |
   |---[Frame 5]----->                        |
```

**Error Handling (Frame 2 Corrupted):**
```
Sender                                    Receiver
   |---[Frame 0]----->                        | Deliver 0
   |---[Frame 1]----->                        | Deliver 1
   |---[Frame 2]---X (error)                  | [Discard]
   |---[Frame 3]----->                        | Buffer 3 (out of order)
   |---[Frame 4]----->                        | Buffer 4
   |                                          |
   |<----[ACK 0,1]----                        | [NAK 2 or selective ACK]
   |<----[NAK 2]------                        |
   |                                          |
   |---[Frame 2]-----> (retransmit ONLY 2)    | 
   |                                          | Insert 2, deliver 2,3,4
   |<----[ACK 2,3,4]--                        |
```

**Advantages:**
- High efficiency (high utilization)
- Only retransmits lost/corrupted frames
- Good for high bandwidth-delay product links
- Pipelining improves throughput

**Disadvantages:**
- Complex implementation
- Requires buffering at receiver
- More state to maintain
- Reordering may be needed at receiver

### iii) Trade-offs in Flow Control Design

**Key Design Trade-offs:**

**1. Window Size vs. Memory:**
- Larger windows → better throughput but more buffer memory needed
- Sender must store all unACKed frames
- Receiver must store out-of-order frames (Selective Repeat)

**2. Sequence Number Bits vs. Overhead:**
- More bits → larger windows possible
- Fewer bits → less header overhead
- Go-Back-N: window ≤ 2^n - 1
- Selective Repeat: window ≤ 2^(n-1)

**3. Complexity vs. Efficiency:**

| Mechanism | Complexity | Efficiency | Suitable For |
|-----------|------------|------------|--------------|
| Stop-and-Wait | Low | Low | Low BDP links |
| Go-Back-N | Medium | Medium | Moderate BDP |
| Selective Repeat | High | High | High BDP links |

**Protocol Header Fields Involved:**
- **Sequence Number (N(S)):** Identifies frame position
- **Acknowledgement Number (N(R)):** Confirms receipt, indicates next expected
- **Window Size:** Advertises receiver buffer space
- **Checksum/CRC:** Enables error detection
- **Flags:** Control bits (ACK, NAK, FIN, etc.)

**State Requirements:**

| | Stop-and-Wait | Go-Back-N | Selective Repeat |
|--|---------------|-----------|------------------|
| Sender buffer | 1 frame | Window frames | Window frames |
| Receiver buffer | 1 frame | 1 frame | Window frames |
| Sender timers | 1 | 1 (or per-frame) | Per-frame |
| Sequence tracking | 1 bit minimum | n bits | n bits + bitmap |

---

## Part b) CRC and Hamming Code [25 marks]

### i) CRC Error Detection

**Data:** 1110111011011 (13 bits)
**Generator Polynomial:** x⁴ + x³ + x + 1 = 11011 (5 bits)

**Sender Process:**

**Step 1:** Append (r) zeros where r = degree of polynomial = 4
```
Data with appended zeros: 11101110110110000
                                      ^^^^
                                      4 zeros appended
```

**Step 2:** Perform polynomial division (XOR operations)

```
        1100011010111
       _______________
11011 ) 11101110110110000
        11011
        -----
        00110110
          11011
          -----
          01101110
           11011
           -----
           01001100
            11011
            -----
            00101000
              11011
              -----
              00011100
                11011
                -----
                00011100
                  11011
                  -----
                  001110
                   11011
                   -----
                   01010  ← Remainder (CRC)
```

**Step 3:** Transmitted codeword = Data + CRC
```
Transmitted: 11101110110110101
             |_____data_____|CRC|
```

**Receiver Process:**

**Step 1:** Divide received codeword by generator polynomial

**If no errors:** Remainder = 0000 → Accept frame

**If errors present:**
```
Received (with error): 11101110100110101
                              ^ bit flipped
                              
Divide by 11011:
Remainder ≠ 0000 → Error detected, request retransmission
```

**CRC vs IPv4 Checksum:**

| Aspect | CRC | IPv4 Checksum |
|--------|-----|---------------|
| Algorithm | Polynomial division | One's complement sum |
| Error detection | Excellent for bursts | Good for random errors |
| Burst detection | All bursts ≤ r bits | Poor burst detection |
| Hardware | Shift registers (fast) | Adders |
| Overhead | Fixed r bits | 16 bits |
| Location | Link layer (Ethernet) | Network layer |

**Advantages of CRC:**
- Detects all single-bit errors
- Detects all double-bit errors
- Detects all odd-number bit errors
- Detects all bursts ≤ polynomial degree
- Very fast hardware implementation

**Disadvantages of CRC:**
- More complex than simple checksums
- Cannot correct errors, only detect

### ii) Hamming Code

**Data sequences:** 1101110 and 0011001 (each 7 bits)

#### Encoding 1101110

**Step 1:** Determine parity bit positions (powers of 2: 1, 2, 4, 8)

For 7 data bits, we need 4 parity bits → 11-bit codeword

**Step 2:** Position mapping
```
Position:  1   2   3   4   5   6   7   8   9  10  11
Type:      P1  P2  D1  P4  D2  D3  D4  P8  D5  D6  D7
Data:      ?   ?   1   ?   1   0   1   ?   1   1   0
```

**Step 3:** Calculate parity bits (even parity)

**P1** (checks positions 1,3,5,7,9,11 - binary ends in 1):
- Positions: 3,5,7,9,11 = 1,1,1,1,0
- Sum = 4 (even) → P1 = 0

**P2** (checks positions 2,3,6,7,10,11 - binary has bit 2):
- Positions: 3,6,7,10,11 = 1,0,1,1,0
- Sum = 3 (odd) → P2 = 1

**P4** (checks positions 4,5,6,7 - binary has bit 4):
- Positions: 5,6,7 = 1,0,1
- Sum = 2 (even) → P4 = 0

**P8** (checks positions 8,9,10,11 - binary has bit 8):
- Positions: 9,10,11 = 1,1,0
- Sum = 2 (even) → P8 = 0

**Final codeword for 1101110:**
```
Position:  1   2   3   4   5   6   7   8   9  10  11
Value:     0   1   1   0   1   0   1   0   1   1   0
```
**Transmitted: 01101010110**

#### Encoding 0011001

```
Position:  1   2   3   4   5   6   7   8   9  10  11
Type:      P1  P2  D1  P4  D2  D3  D4  P8  D5  D6  D7
Data:      ?   ?   0   ?   0   1   1   ?   0   0   1
```

**P1** (1,3,5,7,9,11): 0,0,1,0,1 = 2 → P1 = 0
**P2** (2,3,6,7,10,11): 0,1,1,0,1 = 3 → P2 = 1
**P4** (4,5,6,7): 0,1,1 = 2 → P4 = 0
**P8** (8,9,10,11): 0,0,1 = 1 → P8 = 1

**Final codeword for 0011001:**
```
Position:  1   2   3   4   5   6   7   8   9  10  11
Value:     0   1   0   0   0   1   1   1   0   0   1
```
**Transmitted: 01000111001**

#### Error Detection at Receiver

**Step 1:** Recalculate all parity bits on received word
**Step 2:** Form syndrome S = (S8 S4 S2 S1)
**Step 3:** If S = 0, no error. If S ≠ 0, S indicates error position

**Example:** Receive 01101010**0**10 (bit 9 flipped from 1 to 0)

Recalculate parities:
- P1 check: 0⊕1⊕1⊕1⊕0⊕0 = 1 (error!) → S1 = 1
- P2 check: 1⊕1⊕0⊕1⊕1⊕0 = 0 → S2 = 0
- P4 check: 0⊕1⊕0⊕1 = 0 → S4 = 0
- P8 check: 0⊕0⊕1⊕0 = 1 (error!) → S8 = 1

Syndrome S = 1001 (binary) = 9 → Error at position 9!
Flip bit 9 to correct.

**Hamming Code vs 2D Parity:**

| Aspect | Hamming Code | 2D Parity |
|--------|--------------|-----------|
| Error correction | Single-bit | Single-bit |
| Overhead | log₂(n) bits | √n bits (approx) |
| Detection | SECDED possible | Single + some double |
| Complexity | Moderate | Simple |
| Scalability | Efficient for large blocks | Less efficient |

**Advantages of Hamming:**
- Precise error location
- Efficient overhead (logarithmic)
- Single-bit error correction built-in
- SECDED variant detects double errors

**Disadvantages of Hamming:**
- More complex than 2D parity
- Limited to single-bit correction
- Not suitable for burst errors

---

# Question 2

## Part a) CDMA and CSMA/CD [25 marks]

### i) Code Division Multiple Access (CDMA)

**Concept:**
CDMA allows multiple stations to transmit simultaneously on the same frequency by assigning each station a unique code (chip sequence). The codes are orthogonal, allowing the base station to separate signals mathematically.

**Example Setup:**
- Station 1 chip sequence: C1 = (+1, -1, +1, -1)
- Station 2 chip sequence: C2 = (+1, +1, -1, -1)
- Station 3 chip sequence: C3 = (+1, -1, -1, +1)

All chip sequences are orthogonal: Ci · Cj = 0 for i ≠ j

**Station Transmission Process (3 bits):**

Station 1 transmits: 1, 0, 1
- Bit '1' → +1 → transmits: +C1 = (+1, -1, +1, -1)
- Bit '0' → -1 → transmits: -C1 = (-1, +1, -1, +1)
- Bit '1' → +1 → transmits: +C1 = (+1, -1, +1, -1)

Station 2 transmits: 0, 1, 1
- Bit '0' → -1 → transmits: -C2 = (-1, -1, +1, +1)
- Bit '1' → +1 → transmits: +C2 = (+1, +1, -1, -1)
- Bit '1' → +1 → transmits: +C2 = (+1, +1, -1, -1)

Station 3 transmits: 1, 1, 0
- Bit '1' → +1 → transmits: +C3 = (+1, -1, -1, +1)
- Bit '1' → +1 → transmits: +C3 = (+1, -1, -1, +1)
- Bit '0' → -1 → transmits: -C3 = (-1, +1, +1, -1)

**Combined Signal at Base Station (Bit period 1):**

```
S1: (+1, -1, +1, -1)  [transmitting '1']
S2: (-1, -1, +1, +1)  [transmitting '0']
S3: (+1, -1, -1, +1)  [transmitting '1']
--------------------------
Sum: (+1, -3, +1, +1)
```

**Base Station Decoding Process:**

To decode Station 1's transmission:
1. Take inner product of received signal with C1
2. Divide by chip sequence length (4)

```
Received: (+1, -3, +1, +1)
C1:       (+1, -1, +1, -1)

Inner product = (1)(1) + (-3)(-1) + (1)(1) + (1)(-1)
              = 1 + 3 + 1 - 1 = 4

Decoded value = 4/4 = +1 → Bit '1' ✓
```

Similarly for Station 2:
```
Received: (+1, -3, +1, +1)
C2:       (+1, +1, -1, -1)

Inner product = 1 - 3 - 1 - 1 = -4
Decoded = -4/4 = -1 → Bit '0' ✓
```

### ii) CDMA vs CSMA/CD Comparison

**CDMA Timeline (Simultaneous):**
```
Time →
         |<---- Bit Period 1 ---->|<---- Bit Period 2 ---->|
         
Station 1: [+1,-1,+1,-1] (bit 1)   [-1,+1,-1,+1] (bit 0)
Station 2: [-1,-1,+1,+1] (bit 0)   [+1,+1,-1,-1] (bit 1)
Station 3: [+1,-1,-1,+1] (bit 1)   [+1,-1,-1,+1] (bit 1)

Combined:  [+1,-3,+1,+1]           [+1,+1,-3,+1]

           All transmit simultaneously, no collisions!
```

**CSMA/CD Timeline (Sequential with potential collisions):**
```
Time →
         |-------|-------|-------|-------|-------|-------|
         
Station 1: [Sense idle]--[TX bit 1,0,1]--[Done]
                                         
Station 2: [Sense busy...waiting...][TX bit 0,1,1]--[Done]

Station 3: [Sense busy...waiting............][TX bit 1,1,0]

         Or with collision:
         
Station 1: [TX]---+
                  |--COLLISION!--[JAM]--[Backoff]--[Retry]
Station 2: [TX]---+
```

**Visual Comparison:**

```
CDMA:
|=========================================================|
| S1 S2 S3 S1 S2 S3 S1 S2 S3  (all simultaneous)         |
|=========================================================|
Time: ████████████████████████████████

CSMA/CD:
|========|  |========|  |========|
|   S1   |  |   S2   |  |   S3   |  (sequential)
|========|  |========|  |========|
Time: ████████████████████████████████████████████████████
                                Much longer total time!
```

### iii) Effect of Large Number of Nodes on CSMA/CD

**High Contention Scenario:**

When many nodes compete:
1. Probability of collision increases dramatically
2. More time spent in collision recovery than transmission
3. Throughput drops significantly

```
Collisions per attempt vs Number of Stations:

Collision
Probability
    |
100%├                    xxxxxxxx
    |               xxxxx
    |          xxxxx
 50%├       xxx
    |     xx
    |   xx
    | xx
  0%├x
    └───────────────────────────────→
     2  5  10  20  50  100  Stations
```

**Binary Exponential Backoff Effect:**

After collision n (n ≤ 10):
- Choose random backoff from [0, 2^n - 1] slot times

**Example progression:**
```
Collision 1: Choose from {0, 1}
Collision 2: Choose from {0, 1, 2, 3}
Collision 3: Choose from {0, 1, 2, ..., 7}
...
Collision 10: Choose from {0, 1, ..., 1023}
Collision 11-15: Still {0, ..., 1023}
Collision 16: Give up, report failure
```

**Benefits of Binary Exponential Backoff:**
- Light load: Quick recovery (small backoff windows)
- Heavy load: Stations spread out over time, reducing collision probability
- Adaptive: Automatically adjusts to network conditions

**Drawbacks:**
- Unfairness: Station that just transmitted has advantage (backoff = 0)
- Capture effect: One station may dominate
- Long delays under heavy load
- Throughput collapses beyond ~40% utilization

**Throughput vs Load:**
```
Throughput
    |       ____
    |      /    \
Max ├─────/      \
    |    /        \
    |   /          \___________
    |  /
  0%├─/
    └──────────────────────────→
    0%      40%     80%    100%  Offered Load
         (optimal)  (collapse)
```

---

## Part b) IEEE 802.11 DCF and PCF [25 marks]

### i) 802.11 DCF Operation

**Scenario:** S4 just finished with S3. S2 wants to transmit to S1, S5 wants to transmit to S6. All stations in range.

**DCF with CSMA/CA:**

```
Time →

S4-S3 communication ends
        |
        v
|<--DIFS-->|<---Contention Window (random backoff)--->|

All stations sense medium idle, wait DIFS

S2 picks backoff = 3 slots
S5 picks backoff = 5 slots

|--DIFS--|slot|slot|slot|    S2 counter = 0, WINS!
                    ↓
S5 freezes counter at 2 remaining slots

Exchange between S2 and S1:
══════════════════════════

S2                              S1                     S5
 |                               |                      |
 |--------RTS (duration=X)----->|                      | (frozen)
 |         |<--SIFS-->|          |                      |
 |<-------CTS (duration=Y)------|                      |
 |         |<--SIFS-->|          |                      |
 |--------DATA----------------->|                      |
 |         |<--SIFS-->|          |                      |
 |<-------ACK-------------------|                      |
 |                               |                      |
 
     All other stations set NAV based on RTS/CTS duration
     ════════════════════════════════════════════════════

After S2-S1 completes, NAV expires:

|<--DIFS-->|slot|slot|    S5 resumes, counter = 0

Exchange between S5 and S6:
══════════════════════════

S5                              S6
 |                               |
 |--------RTS------------------>|
 |         |<--SIFS-->|          |
 |<-------CTS-------------------|
 |         |<--SIFS-->|          |
 |--------DATA----------------->|
 |         |<--SIFS-->|          |
 |<-------ACK-------------------|
 |                               |
```

**Inter-Frame Spaces Explained:**

- **DIFS (DCF IFS):** ~50µs. Longest IFS. Stations wait DIFS before contending for new transmission.

- **SIFS (Short IFS):** ~10µs. Shortest IFS. Used between RTS-CTS, CTS-DATA, DATA-ACK. Gives priority to ongoing exchange.

- **Slot Time:** ~20µs. Basic unit for backoff countdown.

**NAV (Network Allocation Vector):**
- Virtual carrier sensing mechanism
- Stations read duration field in RTS/CTS
- Set internal timer (NAV) to defer transmission
- Prevents hidden terminal collisions

### ii) 802.11 PCF Operation

**Point Coordination Function** provides contention-free access using polling by the Access Point (AP).

```
Time →

|<============= Contention-Free Period (CFP) =============>|<= CP =>|

|--PIFS--|                                           |--CF-End--|

AP uses PIFS to seize medium before any station using DIFS

AP                    S2        S1        S5        S6
|                      |         |         |         |
|---Beacon (CFP Start, CF Duration)--------------------->|
|                      |         |         |         |
|---CF-Poll----------->|         |         |         |
|      (to S2)         |         |         |         |
|         |<--SIFS-->| |         |         |         |
|<--Data+CF-ACK--------|         |         |         |
|  (S2 sends to S1)    |         |         |         |
|                      |         |         |         |
|---SIFS---|           |         |         |         |
|---Data+CF-Poll-------|-------->|         |         |
| (delivers S2's data) |  (to S1)|         |         |
|         |<--SIFS-->| |         |         |         |
|<--CF-ACK (or Null)---|---------|         |         |
|  (S1 acknowledges)   |         |         |         |
|                      |         |         |         |
|---SIFS---|           |         |         |         |
|---CF-Poll------------|---------|-------->|         |
|      (to S5)         |         |         |         |
|         |<--SIFS-->| |         |         |         |
|<--Data+CF-ACK--------|---------|---------|         |
|  (S5 sends to S6)    |         |         |         |
|                      |         |         |         |
|---SIFS---|           |         |         |         |
|---Data+CF-Poll-------|---------|---------|-------->|
| (delivers S5's data) |         |         | (to S6) |
|         |<--SIFS-->| |         |         |         |
|<--CF-ACK-------------|---------|---------|---------|
|                      |         |         |         |
|---CF-End (return to DCF contention)--------------->|
|                      |         |         |         |

|<================== Contention Period (DCF) ==================>|
```

**Inter-Frame Spaces in PCF:**

- **PIFS (PCF IFS):** ~30µs. Between SIFS and DIFS. Gives AP priority over stations.

- **SIFS:** Used between poll and response, ensuring quick turnaround.

**PCF Frame Types:**

- **CF-Poll:** AP invites specific station to transmit
- **CF-Ack:** Acknowledges previous frame
- **CF-Poll+Data:** Combines polling with data delivery
- **Data+CF-Ack:** Station data with piggybacked ACK
- **CF-End:** Terminates CFP, returns to DCF

**DCF vs PCF Comparison:**

| Feature | DCF | PCF |
|---------|-----|-----|
| Coordination | Distributed | Centralized (AP) |
| Collisions | Possible | None in CFP |
| Latency | Variable | Bounded |
| Fairness | Probabilistic | Guaranteed |
| Complexity | Lower | Higher |
| Power | Higher (always listening) | Lower (scheduled) |
| QoS Support | Limited | Better |
| Usage | Most common | Rarely implemented |

---

# Question 3

## Part a) NAT and IP Routing [25 marks]

**Topology:** A communicates with E through B, C, D. Node B is NAT gateway.

### Address Configuration

**IPv4 Addresses:**
- Node A: 192.168.0.10/24 (private)
- Node B internal: 192.168.0.1
- Node B external: 134.226.1.1
- Node C: 134.226.1.2
- Node D: 134.226.2.1
- Node E: 134.226.2.10/16

**MAC Addresses:**
- A: AA:AA:AA:AA:AA:AA
- B-int: BB:BB:BB:BB:BB:01
- B-ext: BB:BB:BB:BB:BB:02
- C-left: CC:CC:CC:CC:CC:01
- C-right: CC:CC:CC:CC:CC:02
- D-left: DD:DD:DD:DD:DD:01
- D-right: DD:DD:DD:DD:DD:02
- E: EE:EE:EE:EE:EE:EE

### i) NAT Gateway Operation

**NAT Translation Table at B:**

| Inside Local | Inside Global | Protocol | Outside Global | State |
|--------------|---------------|----------|----------------|-------|
| 192.168.0.10:5000 | 134.226.1.1:40001 | TCP | 134.226.2.10:80 | EST |
| 192.168.0.10:5001 | 134.226.1.1:40002 | TCP | 134.226.2.10:443 | EST |

**Outgoing Processing (A → E):**

1. B receives on internal interface:
   - Src: 192.168.0.10:5000, Dst: 134.226.2.10:80

2. B creates/updates NAT entry

3. B translates:
   - New Src IP: 134.226.1.1
   - New Src Port: 40001
   - Recalculates IP checksum, TCP checksum

4. B forwards to C

**Incoming Processing (E → A):**

1. B receives on external interface:
   - Src: 134.226.2.10:80, Dst: 134.226.1.1:40001

2. B looks up 134.226.1.1:40001 in NAT table

3. B translates:
   - New Dst IP: 192.168.0.10
   - New Dst Port: 5000
   - Recalculates checksums

4. B forwards to A

### ii) IPv4 Packet and Routing

**Original Packet from A:**

| Field | Value |
|-------|-------|
| Src IP | 192.168.0.10 |
| Dst IP | 134.226.2.10 |
| TTL | 64 |
| Protocol | TCP (6) |

**Routing Process:**

**At A:** 134.226.2.10 ∉ 192.168.0.0/24 → send to gateway 192.168.0.1

**At B:** NAT translation, route to 134.226.1.2 (C), TTL=63

**At C:** Route to 134.226.2.1 (D), TTL=62

**At D:** 134.226.2.10 ∈ 134.226.0.0/16 (connected), TTL=61, deliver to E

### iii) Link Layer Frames

**Hop A → B:**
```
ARP: Who has 192.168.0.1? → BB:BB:BB:BB:BB:01
Frame: [BB:BB:BB:BB:BB:01 | AA:AA:AA:AA:AA:AA | 0x0800 | IP:192.168.0.10→134.226.2.10]
```

**Hop B → C:**
```
ARP: Who has 134.226.1.2? → CC:CC:CC:CC:CC:01
Frame: [CC:CC:CC:CC:CC:01 | BB:BB:BB:BB:BB:02 | 0x0800 | IP:134.226.1.1→134.226.2.10]
```

**Hop C → D:**
```
ARP: Who has 134.226.2.1? → DD:DD:DD:DD:DD:01
Frame: [DD:DD:DD:DD:DD:01 | CC:CC:CC:CC:CC:02 | 0x0800 | IP:134.226.1.1→134.226.2.10]
```

**Hop D → E:**
```
ARP: Who has 134.226.2.10? → EE:EE:EE:EE:EE:EE
Frame: [EE:EE:EE:EE:EE:EE | DD:DD:DD:DD:DD:02 | 0x0800 | IP:134.226.1.1→134.226.2.10]
```

---

## Part b) Link State Routing [25 marks]

### i) Establishing Routing Table Using LSR for Node A

**Topology from Figure 2:**
```
          A ---100--- D ---330--- F ---90--- L
          |           |           |          |
         80          130        170         100
          |           |           |          |
          B ---130--- G ---------+--- H --90-- I
          |           |          110   |     120
         110         120          |   160
          |           |           |    |
          C ---150--- E -------- K ----+
```

#### Step 1: Topology Discovery via LSA Flooding

Each node creates a Link State Advertisement (LSA):

**Node A's LSA:**
```
Origin: A
Neighbors: B(80), D(100)
Sequence: 1
```

All nodes flood their LSAs. After flooding converges, A has complete topology database.

**A's Topology Database:**
| Link | Cost |
|------|------|
| A-B | 80 |
| A-D | 100 |
| B-C | 110 |
| B-G | 130 |
| C-E | 150 |
| D-G | 130 |
| D-F | 330 |
| E-K | 160 |
| G-E | 120 |
| G-H | 170 |
| F-H | 170 |
| F-L | 90 |
| H-K | 110 |
| H-L | 100 |
| H-I | 120 |
| K-I | 90 |

#### Step 2: Dijkstra's Shortest Path Algorithm

**Initialization:**
- Confirmed: {A(0, -)}
- Tentative: {}

**Iteration 1:** Examine A's neighbors
- B: 0 + 80 = 80
- D: 0 + 100 = 100

Tentative: {B(80,A), D(100,A)}
Select minimum: B(80)
Confirmed: {A(0,-), B(80,A)}

**Iteration 2:** Examine B's neighbors
- C: 80 + 110 = 190
- G: 80 + 130 = 210

Tentative: {D(100,A), C(190,B), G(210,B)}
Select minimum: D(100)
Confirmed: {A(0,-), B(80,A), D(100,A)}

**Iteration 3:** Examine D's neighbors
- G: min(210, 100+130) = 210 (no change)
- F: 100 + 330 = 430

Tentative: {C(190,B), G(210,B), F(430,D)}
Select: C(190)
Confirmed: {A, B, D, C(190,B)}

**Continue until all nodes confirmed...**

**Final Routing Table for A:**

| Destination | Cost | Next Hop |
|-------------|------|----------|
| B | 80 | B |
| C | 190 | B |
| D | 100 | D |
| E | 310 | B |
| F | 430 | D |
| G | 210 | B |
| H | 380 | B |
| I | 460 | B |
| K | 470 | B |
| L | 480 | B |

### ii) Reaction to Node G Failure

**When G Fails:**

**Node B detects failure:**
1. Link B-G goes down (timeout/keepalive failure)
2. B creates new LSA: "B's neighbors: A(80), C(110)" (G removed)
3. B floods updated LSA with incremented sequence number

**Node E detects failure:**
1. Link E-G goes down
2. E creates new LSA without G
3. E floods updated LSA

**Node D detects failure:**
1. Link D-G goes down
2. D creates new LSA without G
3. D floods updated LSA

**Node H detects failure:**
1. Link H-G goes down
2. H creates new LSA without G
3. H floods updated LSA

**How Node A Processes:**

1. A receives updated LSAs from B, D (directly) and eventually E, H (via flooding)

2. A updates topology database:
   - Removes all links involving G
   - G becomes unreachable

3. A re-runs Dijkstra's algorithm with updated topology

4. A installs new routing table with alternative paths:
   - Path to E: now via C (A→B→C→E) instead of via G
   - Path to H: now via D→F→H instead of via G

**New paths from A after G fails:**

| Destination | Old Path | New Path | New Cost |
|-------------|----------|----------|----------|
| G | A→B→G | Unreachable | ∞ |
| E | A→B→G→E | A→B→C→E | 340 |
| H | A→B→G→H | A→D→F→H | 600 |

**LSR Convergence Benefits:**
- All routers have same view of failure
- No routing loops during convergence
- Fast convergence (triggered by event, not timer)
- Routes recalculated locally using Dijkstra

---

*End of December 2023 Exam Answers*