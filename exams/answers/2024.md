# CSU33031 Computer Networks Exam Answers
## December 2024

---

# Question 1

## Part a) HDLC Flow Control

**One of the tasks of the Link layer in the OSI stack is called "flow control". The High-Level Data Link Control (HDLC) protocol defines a number of types of frames shown in figure 1. Assume that node A, address 10011111, uses HDLC to transmit 4500 bytes in 5 frames to node B, address 11000110. The code in an S-Frame for an acknowledgement is 00 and for a negative acknowledgement is 11. The flag byte consists of the bit-sequence 01111110.**

### i) Draw the exchange of the frames in as much detail as possible for a Stop-and-Wait approach and for a Selective-Repeat approach.

#### Frame Structure Details

Each I-Frame consists of:
- **Flag**: 01111110 (8 bits)
- **Address**: 11000110 (8 bits) - destination address (Node B)
- **Control**: 0 | N(S) [3 bits] | P/F [1 bit] | N(R) [3 bits] = 8 bits
- **Information**: ~900 bytes per frame (4500 bytes ÷ 5 frames)
- **FCS**: Frame Check Sequence (16 bits typically)
- **Flag**: 01111110 (8 bits)

Each S-Frame (ACK/NAK) consists of:
- **Flag**: 01111110
- **Address**: 10011111 (Node A's address for responses)
- **Control**: 10 | Code [2 bits] | P/F | N(R) [3 bits]
  - ACK code: 00
  - NAK code: 11
- **FCS**: Frame Check Sequence
- **Flag**: 01111110

#### Stop-and-Wait Approach

In Stop-and-Wait, the sender transmits one frame and waits for an acknowledgement before sending the next frame.

```
Node A                                              Node B
  |                                                    |
  |------ I-Frame 0 (N(S)=0, ~900 bytes) ------------>|
  |                                                    | (receives, checks FCS)
  |<----- S-Frame RR (Code=00, N(R)=1) ---------------|
  |                                                    |
  |------ I-Frame 1 (N(S)=1, ~900 bytes) ------------>|
  |                                                    | (receives, checks FCS)
  |<----- S-Frame RR (Code=00, N(R)=2) ---------------|
  |                                                    |
  |------ I-Frame 2 (N(S)=2, ~900 bytes) ------------>|
  |                                                    | (receives, checks FCS)
  |<----- S-Frame RR (Code=00, N(R)=3) ---------------|
  |                                                    |
  |------ I-Frame 3 (N(S)=3, ~900 bytes) ------------>|
  |                                                    | (receives, checks FCS)
  |<----- S-Frame RR (Code=00, N(R)=4) ---------------|
  |                                                    |
  |------ I-Frame 4 (N(S)=4, ~900 bytes) ------------>|
  |                                                    | (receives, checks FCS)
  |<----- S-Frame RR (Code=00, N(R)=5) ---------------|
  |                                                    |
```

**Explanation**: Node A sends each frame sequentially, waiting for an RR (Receive Ready) acknowledgement with N(R) indicating the next expected frame before transmitting the next I-Frame. This is inefficient as the channel is idle during round-trip time.

#### Selective-Repeat Approach

In Selective-Repeat, the sender can transmit multiple frames within the window size. Only errored frames are retransmitted.

**Scenario with one error (Frame 2 corrupted):**

```
Node A                                              Node B
  |                                                    |
  |------ I-Frame 0 (N(S)=0) ------------------------>|
  |------ I-Frame 1 (N(S)=1) ------------------------>|
  |------ I-Frame 2 (N(S)=2) -----X (error) --------->| (FCS check fails)
  |------ I-Frame 3 (N(S)=3) ------------------------>|
  |                                                   |
  |<----- S-Frame RR (Code=00, N(R)=2) ---------------| (ACK for 0,1; buffer 3)
  |<----- S-Frame REJ (Code=11, N(R)=2) --------------| (NAK for frame 2)
  |                                                   |
  |------ I-Frame 2 (N(S)=2) RETRANSMIT ------------->|
  |------ I-Frame 4 (N(S)=4) ------------------------>|
  |                                                   |
  |<----- S-Frame RR (Code=00, N(R)=5) ---------------| (All received)
  |                                                   |
```

**Explanation**: With Selective-Repeat, Node A sends frames 0-3 without waiting. Node B buffers out-of-order frames (frame 3) and sends a NAK (REJ with code=11) specifically for frame 2. Only frame 2 is retransmitted, not frames 3 and 4. This is more efficient than Go-Back-N where all frames from the error onwards would need retransmission.

### ii) Discuss the number of bits reserved for the encoding of sequence numbers and the effect of this on the size of sender and receiver windows for Go-Back-N and Selective Repeat.

In the HDLC I-Frame control field shown in Figure 1:
- **N(S)**: 3 bits for send sequence number
- **N(R)**: 3 bits for receive sequence number

With 3 bits, sequence numbers range from 0 to 7 (8 possible values).

**Go-Back-N Window Constraints:**
- Maximum sender window size: **2³ - 1 = 7 frames**
- Receiver window size: **1 frame** (only accepts in-order frames)
- Rationale: If we allowed 8 frames, the receiver couldn't distinguish between a new frame 0 and a retransmitted frame 0 after all 8 were sent.

**Selective-Repeat Window Constraints:**
- Maximum sender window size: **2³⁻¹ = 4 frames**
- Maximum receiver window size: **4 frames**
- Rationale: Both windows must be ≤ 2^(n-1) where n=3 bits. This prevents ambiguity when ACKs are lost. If sender window was larger, a retransmitted frame could be confused with a new frame with the same sequence number.

**Effect on Performance:**
- Larger sequence number fields allow larger windows
- Larger windows improve efficiency on high bandwidth-delay product links
- Extended HDLC uses 7-bit sequence numbers (128 values) for better performance
- The trade-off is increased overhead in the control field

---

## Part b) DCF and CDMA

### i) 802.11 DCF Frame Exchange

**Assume that six stations S1 to S6 use 802.11 radios and are within each other coverage area. Station S5 completed communicating with Station S6. Station S2 intends to transmit to station S3 and station S4 intends to transmit to station S1. The stations will use 802.11 DCF to get access to the medium.**

#### DCF Operation with CSMA/CA

```
Time →

S5→S6 transmission ends
        |
        v
|--DIFS--|----Contention Window (random backoff)----|
        
All stations sense medium idle for DIFS (DCF Inter-Frame Space)

S2 picks random backoff = 3 slots
S4 picks random backoff = 5 slots

|--DIFS--|slot|slot|slot|     S2 transmits
                    ↓
                    S2 counter reaches 0, S2 wins

S4 freezes counter at 2 remaining slots

        S2                    S3                    S4
         |                     |                     |
         |-------RTS--------->|                     | (freezes backoff)
         |                     |                     |
         |<------CTS----------|                     |
         |                     |                     |
         |-------DATA-------->|                     |
         |                     |                     |
         |<------ACK----------|                     |
         |                     |                     |
|--DIFS--|slot|slot|                                 |
                  ↓                                  |
                  S4 counter = 0, S4 wins            |
                                                     |
         S4                    S1                    
         |                     |                     
         |-------RTS--------->|                     
         |                     |                     
         |<------CTS----------|                     
         |                     |                     
         |-------DATA-------->|                     
         |                     |                     
         |<------ACK----------|                     
```

#### Inter-Frame Spaces:

- **DIFS (DCF Inter-Frame Space)**: Stations must sense idle for DIFS before contending. Longest IFS, used before new transmissions.
- **SIFS (Short Inter-Frame Space)**: Used between RTS-CTS, DATA-ACK. Shortest IFS, gives priority to ongoing exchanges.
- **Slot Time**: Basic unit for backoff counter

#### Detailed Exchange:

1. After S5-S6 communication ends, all stations sense medium idle
2. S2 and S4 both want to transmit, wait for DIFS period
3. Both enter contention window, pick random backoff values
4. Whichever has smaller backoff wins (assume S2 with backoff=3)
5. S4 freezes its counter when it detects S2's transmission
6. S2 sends RTS (Request to Send) to S3
7. After SIFS, S3 responds with CTS (Clear to Send)
8. After SIFS, S2 sends DATA frame
9. After SIFS, S3 sends ACK
10. After DIFS, S4 resumes countdown and transmits to S1 using same RTS/CTS/DATA/ACK sequence

### ii) CDMA Signal Decoding

**Given chip sequences:**
- Station 1: +1 +1 -1 -1
- Station 2: +1 -1 +1 -1
- Station 3: +1 -1 -1 +1
- Station 4: +1 +1 +1 +1

**Transmissions:**
- Station 2 transmits: 10 (encoded as +1, -1)
- Station 4 transmits: 01 (encoded as -1, +1)
- Stations 1 and 3 are silent (transmit 0)

#### Calculating the Combined Signal

**For bit 1 (first time slot):**
- S2 sends '1' (+1): transmits +1 × (+1 -1 +1 -1) = (+1 -1 +1 -1)
- S4 sends '0' (-1): transmits -1 × (+1 +1 +1 +1) = (-1 -1 -1 -1)
- S1 silent: (0 0 0 0)
- S3 silent: (0 0 0 0)

Combined signal (bit 1): (+1-1, -1-1, +1-1, -1-1) = **(0, -2, 0, -2)**

**For bit 2 (second time slot):**
- S2 sends '0' (-1): transmits -1 × (+1 -1 +1 -1) = (-1 +1 -1 +1)
- S4 sends '1' (+1): transmits +1 × (+1 +1 +1 +1) = (+1 +1 +1 +1)
- S1 silent: (0 0 0 0)
- S3 silent: (0 0 0 0)

Combined signal (bit 2): (-1+1, +1+1, -1+1, +1+1) = **(0, +2, 0, +2)**

#### Decoding at Station S1

S1 uses its chip sequence (+1 +1 -1 -1) to decode:

**Bit 1:** 
Inner product = (0)(+1) + (-2)(+1) + (0)(-1) + (-2)(-1) = 0 - 2 + 0 + 2 = **0**
Result: 0/4 = 0 → **No data for S1** (silence)

**Bit 2:**
Inner product = (0)(+1) + (+2)(+1) + (0)(-1) + (+2)(-1) = 0 + 2 + 0 - 2 = **0**
Result: 0/4 = 0 → **No data for S1** (silence)

#### Decoding at Station S3

S3 uses its chip sequence (+1 -1 -1 +1) to decode:

**Bit 1:**
Inner product = (0)(+1) + (-2)(-1) + (0)(-1) + (-2)(+1) = 0 + 2 + 0 - 2 = **0**
Result: 0/4 = 0 → **No data for S3** (silence)

**Bit 2:**
Inner product = (0)(+1) + (+2)(-1) + (0)(-1) + (+2)(+1) = 0 - 2 + 0 + 2 = **0**
Result: 0/4 = 0 → **No data for S3** (silence)

#### Discussion

S1 and S3 correctly decode that no data was intended for them, as the inner products yield zero. This demonstrates the orthogonality property of CDMA chip sequences. Each station can extract only the data meant for it by computing the inner product with its unique chip sequence and dividing by the chip length (4). 

Note: If S3 tried to decode S2's transmission using S2's chip sequence, it would get:
- Bit 1: (+1)(+1) + (-1)(-1) + (+1)(+1) + (-1)(-1) = 1+1+1+1 = 4 → 4/4 = +1 (bit '1')
- Bit 2: (0)(+1) + (+2)(-1) + (0)(+1) + (+2)(-1) ... (would decode S2's '0')

---

# Question 2

## Part a) NAT and IP Routing

**Assume that a node A intends to communicate with a node E over a number of intermediate nodes, B to D, as shown in figure 2. The nodes use IEEE 802.3 Ethernet as Link layer protocol for the connections between them and node B acts as a NAT gateway for the local network that includes node A.**

### Assumed Addresses

**IPv4 Addresses:**
- Node A: 192.168.0.10 (private, on 192.168.0.0/24 network)
- Node B (internal): 192.168.0.1
- Node B (external): 134.226.1.1
- Node C: 134.226.1.2
- Node D: 134.226.2.1
- Node E: 134.226.2.10

**Ethernet MAC Addresses:**
- Node A: AA:AA:AA:AA:AA:AA
- Node B (internal): BB:BB:BB:BB:BB:01
- Node B (external): BB:BB:BB:BB:BB:02
- Node C (left): CC:CC:CC:CC:CC:01
- Node C (right): CC:CC:CC:CC:CC:02
- Node D (left): DD:DD:DD:DD:DD:01
- Node D (right): DD:DD:DD:DD:DD:02
- Node E: EE:EE:EE:EE:EE:EE

### i) NAT Gateway Information and Processing

**NAT Translation Table at Node B:**

| Internal IP:Port  | External IP:Port  | Protocol | Destination      |
| ----------------- | ----------------- | -------- | ---------------- |
| 192.168.0.10:5000 | 134.226.1.1:40001 | TCP      | 134.226.2.10:80  |
| 192.168.0.10:5001 | 134.226.1.1:40002 | TCP      | 134.226.2.10:443 |
| ...               | ...               | ...      | ...              |

**Outgoing Packet Processing (A → E):**
1. B receives packet from A with source 192.168.0.10:5000, destination 134.226.2.10:80
2. B creates NAT table entry mapping internal address to external port
3. B rewrites source IP to 134.226.1.1 and source port to 40001
4. B recalculates IP header checksum and TCP/UDP checksum
5. B forwards packet toward E

**Incoming Packet Processing (E → A):**
1. B receives packet with destination 134.226.1.1:40001
2. B looks up 134.226.1.1:40001 in NAT table
3. B finds mapping to 192.168.0.10:5000
4. B rewrites destination IP to 192.168.0.10 and port to 5000
5. B recalculates checksums
6. B forwards packet to A on internal network

### ii) IPv4 Packet and Routing Process

**Original IPv4 Packet from A:**

| Field          | Value               |
| -------------- | ------------------- |
| Version        | 4                   |
| Header Length  | 5 (20 bytes)        |
| TTL            | 64                  |
| Protocol       | 6 (TCP) or 17 (UDP) |
| Source IP      | 192.168.0.10        |
| Destination IP | 134.226.2.10        |
| Payload        | Application data    |

**Routing Process:**

**At Node A:**
- A checks: Is 134.226.2.10 on my network (192.168.0.0/24)? No.
- A consults routing table, finds default gateway: 192.168.0.1 (B)
- A sends packet to B

**At Node B (NAT Gateway):**
- B receives packet, performs NAT translation
- Source IP becomes: 134.226.1.1
- B checks routing table for 134.226.2.10
- Next hop: 134.226.1.2 (C)
- TTL decremented to 63

**At Node C (Router):**
- C receives packet, checks destination 134.226.2.10
- Consults routing table: next hop is D (134.226.2.1)
- TTL decremented to 62
- Forwards to D

**At Node D (Router):**
- D receives packet, checks destination 134.226.2.10
- 134.226.2.10 is on directly connected network 134.226.2.0/24
- TTL decremented to 61
- Forwards directly to E

### iii) Link Layer Frames and Address Resolution

*Hop 1: A → B**

Before sending, A needs B's MAC address:
- A checks ARP cache for 192.168.0.1
- If not found, A broadcasts ARP Request: "Who has 192.168.0.1?"
- B responds: "192.168.0.1 is at BB:BB:BB:BB:BB:01"

Ethernet Frame:
| Dest MAC | Source MAC | Type | Payload (IP Packet) | FCS |
|----------|------------|------|---------------------|-----|
| BB:BB:BB:BB:BB:01 | AA:AA:AA:AA:AA:AA | 0x0800 | [IP: 192.168.0.10 → 134.226.2.10] | ... |

**Hop 2: B → C**

B performs NAT, then needs C's MAC:
- B sends ARP for 134.226.1.2, gets CC:CC:CC:CC:CC:01

Ethernet Frame:
| Dest MAC | Source MAC | Type | Payload (IP Packet) | FCS |
|----------|------------|------|---------------------|-----|
| CC:CC:CC:CC:CC:01 | BB:BB:BB:BB:BB:02 | 0x0800 | [IP: 134.226.1.1 → 134.226.2.10] | ... |

**Hop 3: C → D**

C needs D's MAC:
- C sends ARP for 134.226.2.1, gets DD:DD:DD:DD:DD:01

Ethernet Frame:
| Dest MAC | Source MAC | Type | Payload (IP Packet) | FCS |
|----------|------------|------|---------------------|-----|
| DD:DD:DD:DD:DD:01 | CC:CC:CC:CC:CC:02 | 0x0800 | [IP: 134.226.1.1 → 134.226.2.10] | ... |

**Hop 4: D → E**

D needs E's MAC:
- D sends ARP for 134.226.2.10, gets EE:EE:EE:EE:EE:EE

Ethernet Frame:
| Dest MAC | Source MAC | Type | Payload (IP Packet) | FCS |
|----------|------------|------|---------------------|-----|
| EE:EE:EE:EE:EE:EE | DD:DD:DD:DD:DD:02 | 0x0800 | [IP: 134.226.1.1 → 134.226.2.10] | ... |

**Key Observation:** The IP addresses remain constant (after NAT), but MAC addresses change at every hop, reflecting the next-hop link layer addressing.

---

## Part b) Distance Vector and Link State Routing

### i) Description and Comparison

**Distance Vector Routing:**
Distance Vector routing is a distributed routing protocol where each router maintains a table (vector) of the best known distance to every destination and the next-hop to reach it. Routers periodically share their entire routing tables with directly connected neighbors. Each router updates its table using the Bellman-Ford equation: if a neighbor advertises a shorter path to a destination, the router updates its entry. The router only knows the distance and direction (next hop) to destinations, not the complete network topology.

**Link State Routing:**
Link State routing requires each router to build a complete map of the network topology. Every router discovers its neighbors and the cost to reach them, then floods this information throughout the network as Link State Advertisements (LSAs). Once all routers have the same topology database, each independently runs Dijkstra's shortest-path algorithm to compute the best route to every destination.

**Key Differences:**

| Aspect      | Distance Vector                | Link State                      |
| ----------- | ------------------------------ | ------------------------------- |
| Knowledge   | Only next-hop and distance     | Complete topology               |
| Updates     | Periodic, entire routing table | Event-driven, only link changes |
| Algorithm   | Bellman-Ford (distributed)     | Dijkstra (local computation)    |
| Convergence | Slower, prone to loops         | Faster, loop-free               |
| Memory      | Lower (just routing table)     | Higher (full topology database) |
| Bandwidth   | Higher (full tables shared)    | Lower (only LSAs flooded)       |
| Examples    | RIP, EIGRP                     | OSPF, IS-IS                     |

### ii) Distance Vector Routing Example at TCD

Consider a simplified TCD network with 6 of the 12 schools:

```
        [CSS]----2----[EE]
         / \            |
        1   3           4
       /     \          |
    [Math]   [Physics]--2--[Chemistry]
       \                    /
        5                  3
         \                /
          ----[Genetics]--
```

**Initial State (t=0):**
Each router only knows its directly connected neighbors.

CSS Routing Table:
| Destination | Distance | Next Hop |
|-------------|----------|----------|
| CSS | 0 | - |
| EE | 2 | EE |
| Math | 1 | Math |
| Physics | 3 | Physics |

**After First Exchange (t=1):**
Routers exchange tables with neighbors.

CSS receives from EE: "Chemistry is 4 hops away"
CSS calculates: 2 (to EE) + 4 (EE to Chemistry) = 6

CSS receives from Physics: "Chemistry is 2 hops away"
CSS calculates: 3 (to Physics) + 2 (Physics to Chemistry) = 5 ← Better!

Updated CSS Table:
| Destination | Distance | Next Hop |
|-------------|----------|----------|
| CSS | 0 | - |
| EE | 2 | EE |
| Math | 1 | Math |
| Physics | 3 | Physics |
| Chemistry | 5 | Physics |
| Genetics | 6 | Math |

**Convergence Process:**
```
Round 1: Each router shares table with neighbors
Round 2: Routers update based on received info, share again
Round 3: Process repeats
...
Round N: Tables stabilize - convergence achieved
```

The process continues until no router updates its table, indicating convergence.

### iii) Count to Infinity Problem

**Scenario:**
Consider the link between CSS and Physics fails:

```
Before:
[CSS]---3---[Physics]---2---[Chemistry]

After link failure:
[CSS]  X    [Physics]---2---[Chemistry]
```

**The Problem Unfolds:**

1. **Initially:** CSS reaches Chemistry via Physics with cost 5 (3+2)

2. **Link CSS-Physics fails:** CSS should mark Chemistry as unreachable

3. **But:** CSS receives update from Math: "I can reach Chemistry in 7 hops" (Math's old route via CSS→Physics→Chemistry, which Math doesn't know is broken)

4. **CSS updates:** "Chemistry is 8 hops via Math" (1 + 7)

5. **Math receives from CSS:** "Chemistry is 8 hops away"

6. **Math updates:** "Chemistry is 9 hops via CSS" (wait, this goes through CSS who routes through me...)

7. **This ping-pong continues:**
   - CSS: 10, 12, 14, 16...
   - Math: 11, 13, 15, 17...

8. **The counters increment toward infinity** until they exceed a defined maximum (e.g., 16 in RIP, which means "unreachable")

**Why It Happens:**
- Routers don't know the complete topology
- "Good news travels fast, bad news travels slow"
- Routing loops form because neither router knows the other's path goes through itself

**Solutions:**
- **Split Horizon:** Don't advertise a route back to the neighbor you learned it from
- **Poison Reverse:** Advertise routes learned from a neighbor back to that neighbor with infinite cost
- **Hold-down timers:** Wait before accepting new routes to a recently-failed destination
- **Triggered updates:** Send updates immediately when changes occur, not just periodically
- **Maximum hop count:** Define infinity as a small number (e.g., 16) to limit convergence time

---

*End of Exam Answers*
