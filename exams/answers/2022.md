# CSU33031 Computer Networks Exam Answers
## December 2022

---

# Question 1

## Part a) HDLC Flow Control [30 marks]

**One of the tasks of the Link layer in the OSI stack is called "flow control". The High-Level Data Link Control (HDLC) protocol defines a number of types of frames shown in figure 1. Assume that node A, address 10000011, uses HDLC to send 5 frames to node B, address 11011111. The code in the S-Frame for an acknowledgement is 00 and for a negative acknowledgement is 11. The flag byte consists of the bit-sequence 01111110.**

### i) Draw the exchange of the frames in as much detail as possible for a Stop-and-Wait approach and for a Selective-Repeat approach.

#### Frame Structure Details

**I-Frame (Information Frame):**
- Flag: 01111110 (8 bits)
- Address: 11011111 (Node B - destination, 8 bits)
- Control: 0 | N(S) [3 bits] | P/F [1 bit] | N(R) [3 bits] = 8 bits
- Information: Data payload
- FCS: Frame Check Sequence (16 bits)
- Flag: 01111110 (8 bits)

**S-Frame (Supervisory Frame):**
- Flag: 01111110
- Address: 10000011 (Node A - for responses)
- Control: 10 | Code [2 bits] | P/F | N(R) [3 bits]
  - ACK (RR) code: 00
  - NAK (REJ) code: 11
- FCS: Frame Check Sequence
- Flag: 01111110

#### Stop-and-Wait Approach

In Stop-and-Wait, the sender transmits one frame and waits for acknowledgement before sending the next.

**Assumption:** All frames transmitted successfully without errors.

```
Node A (10000011)                                   Node B (11011111)
      |                                                    |
      |  I-Frame 0                                         |
      |  [01111110|11011111|0|000|P|000|Data|FCS|01111110] |
      |--------------------------------------------------->|
      |                                                    | (Process frame)
      |  S-Frame RR                                        |
      |  [01111110|10000011|10|00|P|001|FCS|01111110]      |
      |<---------------------------------------------------|
      |                                                    |
      |  I-Frame 1                                         |
      |  [01111110|11011111|0|001|P|000|Data|FCS|01111110] |
      |--------------------------------------------------->|
      |                                                    |
      |  S-Frame RR (N(R)=2)                               |
      |<---------------------------------------------------|
      |                                                    |
      |  I-Frame 2                                         |
      |--------------------------------------------------->|
      |                                                    |
      |  S-Frame RR (N(R)=3)                               |
      |<---------------------------------------------------|
      |                                                    |
      |  I-Frame 3                                         |
      |--------------------------------------------------->|
      |                                                    |
      |  S-Frame RR (N(R)=4)                               |
      |<---------------------------------------------------|
      |                                                    |
      |  I-Frame 4                                         |
      |--------------------------------------------------->|
      |                                                    |
      |  S-Frame RR (N(R)=5)                               |
      |<---------------------------------------------------|
      |                                                    |
```

**Explanation:** Node A sends frame 0 with N(S)=0, waits for ACK. Node B responds with RR (code=00) and N(R)=1 indicating it expects frame 1 next. This continues sequentially until all 5 frames are transmitted. The process is simple but inefficient as the channel is idle during the round-trip time waiting for each ACK.

#### Selective-Repeat Approach

**Assumption:** Frame 2 is corrupted during transmission.

```
Node A (10000011)                                   Node B (11011111)
      |                                                    |
      |------ I-Frame 0 (N(S)=0) ------------------------->|
      |------ I-Frame 1 (N(S)=1) ------------------------->|
      |------ I-Frame 2 (N(S)=2) -------X (corrupted) ---->| (FCS fails)
      |------ I-Frame 3 (N(S)=3) ------------------------->| (buffered)
      |------ I-Frame 4 (N(S)=4) ------------------------->| (buffered)
      |                                                    |
      |<----- S-Frame RR (Code=00, N(R)=2) ----------------| (ACK 0,1)
      |<----- S-Frame REJ (Code=11, N(R)=2) ---------------| (NAK frame 2)
      |                                                    |
      |------ I-Frame 2 (N(S)=2) RETRANSMIT -------------->|
      |                                                    | (Inserts frame 2)
      |                                                    | (Delivers 2,3,4)
      |<----- S-Frame RR (Code=00, N(R)=5) ----------------| (All received)
      |                                                    |
```

**Explanation:** With Selective-Repeat, Node A sends multiple frames within its window without waiting. Node B receives frames 0 and 1 correctly, detects corruption in frame 2 (FCS check fails), but still accepts and buffers frames 3 and 4. Node B sends an RR acknowledging frames 0-1 and a REJ (code=11) requesting retransmission of frame 2 only. Node A retransmits only frame 2. Once received correctly, Node B delivers all frames in order. This is more efficient than Go-Back-N which would require retransmitting frames 2, 3, and 4.

### ii) Explain the process that takes place when the information being transferred includes the same bit-sequence as the flag byte.

This problem is solved through **Bit Stuffing** (also called bit-level framing or zero-bit insertion).

**The Problem:**
The flag byte 01111110 marks frame boundaries. If the data payload contains this same sequence, the receiver would incorrectly interpret it as an end-of-frame marker.

**The Solution - Bit Stuffing Process:**

**At the Sender (Transmission):**
1. The sender scans the data between the opening and closing flags
2. Whenever it encounters **five consecutive 1s** (11111), it automatically inserts a 0 after them
3. This ensures that the pattern 01111110 can never appear in the data
4. The flags themselves are NOT stuffed

**Example:**
```
Original data:    01111110 01110 (contains flag-like sequence)
After stuffing:   011111010 011100
                        ^
                        Stuffed 0 inserted after five 1s
```

**At the Receiver:**
1. The receiver examines the bit stream between flags
2. Whenever it sees five consecutive 1s followed by a 0, it removes that 0
3. This restores the original data
4. If it sees five 1s followed by a 1 (making 01111110), it recognizes this as a flag

**Decision Table:**
| Pattern Seen | Action |
|-------------|--------|
| 111110 | Remove the 0, data was stuffed |
| 1111110 | Flag detected (end of frame) |
| 11111110 | Error condition (invalid) |

**Example Transmission:**
```
Original payload:     0110111111001010
                           ^^^^^
                           Five 1s detected

Transmitted (stuffed): 01101111110001010
                              ^
                              Stuffed 0 inserted

Received and destuffed: 0110111111001010
                              ^
                              Stuffed 0 removed
```

This mechanism is transparent to higher layers and ensures that flag sequences in data don't cause framing errors.

---

## Part b) Error Detection Mechanisms [20 marks]

### i) Difference between Checksums and Hamming Code

**IPv4 Header Checksum:**
- Operates on 16-bit words of the header
- Uses one's complement addition: sum all 16-bit words, then take one's complement of result
- Detects many common errors but NOT all errors
- Cannot identify which bit is in error
- Simple and fast to compute in software
- Must be recalculated at every hop (TTL changes)

**Hamming Code:**
- Adds redundant parity bits at specific positions (powers of 2: 1, 2, 4, 8, ...)
- Each parity bit covers a specific subset of data bits
- Can **detect AND correct** single-bit errors
- Can detect (but not correct) double-bit errors
- More redundancy overhead than simple checksums
- Position of error can be precisely identified

**Suitability Comparison:**

| Aspect | IPv4 Checksum | Hamming Code |
|--------|---------------|--------------|
| Purpose | Error detection only | Detection AND correction |
| Speed | Very fast | More computation |
| Overhead | 16 bits for entire header | Multiple parity bits per data block |
| Use case | End-to-end verification | Link layer, memory systems |
| Recalculation | Every hop (TTL changes) | Once per transmission |

**Why Checksums suit IP Headers:**
- IP is end-to-end; if errors detected, packet is simply dropped and retransmitted by TCP
- Speed is critical at every router
- Header is small (20-60 bytes)
- TTL field changes at each hop, requiring recalculation anyway

**Why Hamming Code suits Link Layer:**
- Link layer operates hop-by-hop over physical medium
- Physical media have higher bit error rates
- Correction avoids retransmission overhead
- Real-time/low-latency requirements benefit from correction without retransmit

### ii) Demonstrate Checksum and Hamming Code on "1001001 0100010 1000011"

#### Checksum Calculation

Data: 1001001 0100010 1000011 (three 7-bit sequences)

**Step 1:** Treat as 16-bit words (padding if necessary)
- Word 1: 1001001 0100010 = 1001001 0100010 (padding to 16 bits if needed)

For simplicity, treating as three 7-bit values and summing:

```
  1001001  (73 decimal)
+ 0100010  (34 decimal)
+ 1000011  (67 decimal)
---------
= 10101110 (174 decimal, but we work in binary)
```

**Binary addition with carry wraparound:**
```
  1001001
+ 0100010
---------
  1101011

  1101011
+ 1000011
---------
 10101110
```

If there's a carry beyond the word size, wrap it around:
- Result: 10101110 (if 7-bit) → carry the 1: 0101110 + 1 = 0101111

**Checksum (one's complement):** ~0101111 = **1010000**

**Verification:** Sum all words including checksum; result should be all 1s.

#### Hamming Code Calculation

For the 7-bit sequence **1001001**:

**Position mapping:** (positions 1,2,4 are parity bits)
```
Position:  1   2   3   4   5   6   7   8   9  10  11
Type:      P1  P2  D1  P4  D2  D3  D4  P8  D5  D6  D7
Data:      ?   ?   1   ?   0   0   1   ?   0   0   1
```

**Calculate parity bits:**

- **P1** (position 1): covers positions 1,3,5,7,9,11 (binary ending in 1)
  - Covers: P1, 1, 0, 1, 0, 1 → P1 ⊕ 1 ⊕ 0 ⊕ 1 ⊕ 0 ⊕ 1 = 0
  - P1 = 1 (to make even parity)

- **P2** (position 2): covers positions 2,3,6,7,10,11 (binary has bit 1 set)
  - Covers: P2, 1, 0, 1, 0, 1 → P2 = 1

- **P4** (position 4): covers positions 4,5,6,7 (binary has bit 2 set)
  - Covers: P4, 0, 0, 1 → P4 = 1

- **P8** (position 8): covers positions 8,9,10,11
  - Covers: P8, 0, 0, 1 → P8 = 1

**Final Hamming codeword for 1001001:**
```
Position:  1   2   3   4   5   6   7   8   9  10  11
Value:     1   1   1   1   0   0   1   1   0   0   1
```
**Transmitted: 11110011001**

For **0100010** and **1000011**, the same process applies to generate their respective Hamming codewords.

**Error Detection at Receiver:**
1. Recalculate all parity bits
2. Form syndrome from mismatches (P8 P4 P2 P1)
3. Syndrome value = position of error bit
4. Flip that bit to correct

### iii) CRC vs Checksums and Hamming Code for Ethernet

**Cyclic Redundancy Check (CRC) Characteristics:**
- Uses polynomial division (modulo-2 arithmetic)
- Treats data as coefficients of a polynomial
- Divides by a generator polynomial; remainder is CRC
- Ethernet uses CRC-32 (32-bit remainder)
- Excellent burst error detection capability
- Implemented efficiently in hardware using shift registers

**Why CRC is Superior for Ethernet Frames:**

| Factor | CRC | Checksum | Hamming |
|--------|-----|----------|---------|
| Burst error detection | Excellent (detects all bursts ≤ degree of polynomial) | Poor | Poor |
| Hardware implementation | Very efficient (XOR + shift registers) | Requires adders | Complex |
| Overhead | Fixed (32 bits for CRC-32) | 16 bits | Logarithmic in data size |
| Error correction | Detection only | Detection only | Detection + correction |
| Frame size handling | Handles variable length well | Good | Impractical for large frames |

**Why Checksums are Less Suitable:**
- Simple checksums miss many error patterns that preserve the sum
- Swapping two 16-bit words goes undetected
- Not designed for the burst errors common on physical media

**Why Hamming Code is Less Suitable:**
- For a 1500-byte Ethernet frame (12000 bits), would need ~14 parity bits per block
- Overhead becomes significant for large frames
- Designed for single-bit errors; Ethernet experiences burst errors
- Correction capability is wasted (Ethernet uses retransmission anyway)

**CRC Advantages for Ethernet:**
- Detects all single-bit errors
- Detects all double-bit errors
- Detects all odd numbers of bit errors
- Detects all burst errors up to 32 bits
- Detects most longer burst errors (probability of missing: 2^-32)
- Hardware implementation is extremely fast (wire speed)

---

# Question 2

## Part a) Medium Access Protocols [25 marks]

### i) Time-Division Multiple Access (TDMA)

**TDMA Operation:**
In TDMA, time is divided into fixed-length frames, and each frame is subdivided into time slots. Each of the 6 stations is assigned a dedicated slot within each frame.

```
|<------------------------ Frame Period ------------------------>|
|  Slot 1  |  Slot 2  |  Slot 3  |  Slot 4  |  Slot 5  |  Slot 6  |
|    S1    |    S2    |    S3    |    S4    |    S5    |    S6    |
|__________|__________|__________|__________|__________|__________|

|<------------------------ Next Frame -------------------------->|
|  Slot 1  |  Slot 2  |  Slot 3  |  Slot 4  |  Slot 5  |  Slot 6  |
|    S1    |    S2    |    S3    |    S4    |    S5    |    S6    |
```

**How Stations Gain Access:**
1. Each station is pre-assigned a specific time slot
2. Stations maintain synchronized clocks
3. When a station's slot arrives, it can transmit
4. If a station has no data, its slot goes unused (wasted)
5. Transmission must complete within the slot duration

**Advantages of TDMA:**
- No collisions - each station has guaranteed access
- Deterministic latency - maximum wait time is known
- Fair bandwidth allocation
- Simple to understand and implement
- Suitable for real-time applications

**Disadvantages of TDMA:**
- Wasted bandwidth when stations have no data to send
- Inflexible - cannot adapt to varying traffic demands
- Requires precise synchronization between all stations
- Fixed number of stations - adding/removing requires reconfiguration
- Maximum throughput per station is limited to 1/N of total capacity

**Visualization of Inefficiency:**
```
Time →
|  S1   |  S2   |  S3   | EMPTY | EMPTY |  S6   |
| data  | data  | data  |  S4   |  S5   | data  |
                        |idle   |idle   |
                        ↑_______↑
                        Wasted capacity
                        (S4, S5 have no data)
```

### ii) Alternative Protocol: CSMA/CD (Carrier Sense Multiple Access with Collision Detection)

**Why CSMA/CD is Suitable:**
CSMA/CD dynamically allocates the medium based on demand, making it ideal for varying numbers of stations.

**CSMA/CD Procedure:**

```
Station wants to transmit
         |
         v
+-------------------+
| Carrier Sense     |<----+
| (Is medium busy?) |     |
+-------------------+     |
    |           |         |
    No          Yes       |
    |           |         |
    v           +----wait-+
+-------------------+
| Transmit frame    |
+-------------------+
         |
         v
+-------------------+
| Collision         |
| detected?         |
+-------------------+
    |           |
    No          Yes
    |           |
    v           v
Success    +-------------------+
           | Send jam signal   |
           +-------------------+
                    |
                    v
           +-------------------+
           | Binary Exponential|
           | Backoff           |
           +-------------------+
                    |
                    v
           Wait random time, retry
```

**Contention and Collision Example:**

```
Time →
        S2                    S3
         |                     |
t0       | Carrier sense: idle |
         |                     |
t1       |---transmit------    |---transmit------
         |                     |
t2       |     COLLISION       |
         |        X            |
         |                     |
t3       |--JAM--|             |--JAM--|
         |                     |
t4       | Backoff: 0-1 slots  | Backoff: 0-1 slots
         | (picks 0)           | (picks 1)
         |                     |
t5       |---transmit (wins)---|
         |                     | (waiting)
         |                     |
t6       | Success             |
         |                     |---transmit---
         |                     |
t7       |                     | Success
```

**Binary Exponential Backoff:**
- After collision n, choose random backoff from [0, 2^n - 1] slot times
- n=1: choose from {0, 1}
- n=2: choose from {0, 1, 2, 3}
- n=3: choose from {0, 1, 2, 3, 4, 5, 6, 7}
- Maximum n = 10 (range 0-1023)
- After 16 collisions, give up and report error

**Advantages of CSMA/CD:**
- Adapts to any number of stations
- Efficient under light load (immediate access if idle)
- No wasted slots when stations are silent
- No central coordination needed
- Simple to add/remove stations

**Disadvantages of CSMA/CD:**
- Performance degrades under heavy load (many collisions)
- Non-deterministic access time
- Not suitable for real-time guarantees
- Collision overhead wastes bandwidth
- Minimum frame size requirement (for collision detection)

---

## Part b) IEEE 802.11 DCF and PCF [25 marks]

### i) 802.11 DCF Operation

**Scenario:** S2 wants to transmit to S4, S6 wants to transmit to S1. All stations are in range of each other.

**DCF with CSMA/CA and RTS/CTS:**

```
Time →

|<----DIFS---->|<--Contention Window (Backoff)-->|
               
All stations sense medium idle for DIFS period

S2 picks random backoff = 2 slots
S6 picks random backoff = 4 slots

|--DIFS--|slot|slot|  S2 WINS (counter=0 first)
                 ↓
         S6 freezes at 2 remaining slots

S2                              S4                    S6
 |                               |                     |
 |--------RTS------------------>|                     | (freezes counter)
 |                               |                     |
 |<-------CTS-------------------|                     |
 |                               |                     |
 |--------DATA----------------->|                     |
 |                               |                     |
 |<-------ACK-------------------|                     |
 |                               |                     |

|<-SIFS->|      |<-SIFS->|      |<-SIFS->|

     NAV set by RTS (others defer)
     ====================================

After S2-S4 exchange completes:

|--DIFS--|slot|slot|  S6 WINS (resumes countdown)

S6                              S1
 |                               |
 |--------RTS------------------>|
 |                               |
 |<-------CTS-------------------|
 |                               |
 |--------DATA----------------->|
 |                               |
 |<-------ACK-------------------|
 |                               |
```

**Inter-Frame Spaces:**

- **DIFS (DCF Inter-Frame Space):** Longest IFS; stations must wait DIFS before contending. Used before new transmissions.
  
- **SIFS (Short Inter-Frame Space):** Shortest IFS; used between RTS-CTS, CTS-DATA, DATA-ACK. Gives priority to ongoing exchanges.

- **Slot Time:** Basic unit for backoff countdown.

**Frame Exchange:**
1. Station waits for DIFS of idle medium
2. Enters contention window, counts down random backoff
3. Winner sends RTS (Request to Send) specifying duration
4. Other stations set NAV (Network Allocation Vector) based on duration
5. Destination responds with CTS after SIFS
6. Sender transmits DATA after SIFS
7. Receiver sends ACK after SIFS
8. Other stations resume contention after NAV expires + DIFS

### ii) 802.11 PCF Operation

**Point Coordination Function** uses a Point Coordinator (PC), typically the Access Point (AP), to poll stations in a contention-free manner.

```
Time →

Contention-Free Period (CFP)
|<================================================================>|

|--PIFS--|                                                    |--CFP-End--|

AP                   S2                   S4                   S6        S1
|                     |                    |                    |         |
|                     |                    |                    |         |
|---Beacon (CFP Start)-------------------------------------------------->|
|                     |                    |                    |         |
|--CF-Poll + Data --->|                    |                    |         |
|    (to S2)          |                    |                    |         |
|<---SIFS-------------|                    |                    |         |
|<--Data + CF-ACK-----|                    |                    |         |
|    (S2→S4 data via AP)                   |                    |         |
|                     |                    |                    |         |
|--SIFS-------------->|                    |                    |         |
|--CF-Poll + Data-----|-------------------->|                   |         |
|    (delivers S2's data to S4)            |                    |         |
|                     |                    |<--SIFS             |         |
|<------------------CF-ACK-----------------|                    |         |
|                     |                    |                    |         |
|--SIFS---------------|                    |                    |         |
|--CF-Poll------------|--------------------|------------------->|         |
|    (polling S6)     |                    |                    |         |
|                     |                    |                    |<-SIFS   |
|<--Data + CF-ACK (S6→S1 data)---------------------------|         |
|                     |                    |                    |         |
|--SIFS---------------|                    |                    |         |
|--CF-Poll + Data-----|--------------------|--------------------|-------->|
|    (delivers S6's data to S1)            |                    |         |
|                     |                    |                    |  <SIFS  |
|<--CF-ACK--------------------------------------------------------|
|                     |                    |                    |         |
|--CF-End (returns to DCF contention period)----------------------------→|
|                     |                    |                    |         |

|<===== Contention Period (DCF) =====>|
```

**Inter-Frame Spaces in PCF:**

- **PIFS (PCF Inter-Frame Space):** Between SIFS and DIFS. AP uses PIFS to gain priority over stations using DCF.

- **SIFS:** Used between poll and response, between consecutive frames.

**Key Differences between DCF and PCF:**

| Aspect | DCF | PCF |
|--------|-----|-----|
| Coordination | Distributed (all stations) | Centralized (AP) |
| Access method | Contention-based | Polling-based |
| Collisions | Possible | None during CFP |
| Latency | Variable | More predictable |
| Fairness | Probabilistic | Guaranteed by poll order |
| Overhead | Backoff time | Polling overhead |
| Suitable for | Best-effort traffic | Real-time, QoS |

---

# Question 3

## Part a) NAT and IP Routing [25 marks]

**Assume that a node A intends to communicate with a node E over a number of intermediate nodes, B to D, as shown in figure 2. The nodes use IEEE 802.3 Ethernet as Link layer protocol for the connections between them and node B acts as a NAT gateway for the local network that includes node A.**

### Assumed Address Configuration

**IPv4 Addresses:**
- Node A: 192.168.0.10 (private, on 192.168.0.0/24)
- Node B (internal): 192.168.0.1 (gateway for A)
- Node B (external): 55.66.1.1
- Node C: 55.66.1.2
- Node D: 55.66.2.1
- Node E: 55.66.2.10 (on 55.66.0.0/16 network)

**MAC Addresses:**
- A: AA:AA:AA:AA:AA:AA
- B-internal: BB:BB:BB:BB:BB:01
- B-external: BB:BB:BB:BB:BB:02
- C-left: CC:CC:CC:CC:CC:01
- C-right: CC:CC:CC:CC:CC:02
- D-left: DD:DD:DD:DD:DD:01
- D-right: DD:DD:DD:DD:DD:02
- E: EE:EE:EE:EE:EE:EE

### i) NAT Gateway Information and Processing

**NAT Translation Table at Node B:**

| Internal IP:Port | External IP:Port | Protocol | Remote Host:Port | Timestamp |
|------------------|------------------|----------|------------------|-----------|
| 192.168.0.10:4000 | 55.66.1.1:50001 | TCP | 55.66.2.10:80 | ... |
| 192.168.0.10:4001 | 55.66.1.1:50002 | UDP | 55.66.2.10:53 | ... |

**Outgoing Packet Processing (A → E):**

1. **Receive:** B receives packet on internal interface from A
   - Source: 192.168.0.10:4000
   - Destination: 55.66.2.10:80

2. **Lookup/Create Entry:** B checks NAT table for existing mapping
   - If none exists, creates new entry with available external port

3. **Translate:** B modifies packet header
   - New Source IP: 55.66.1.1
   - New Source Port: 50001 (from NAT table)
   - Recalculates IP header checksum
   - Recalculates TCP/UDP checksum

4. **Forward:** B sends packet out external interface toward C

**Incoming Packet Processing (E → A):**

1. **Receive:** B receives packet on external interface
   - Source: 55.66.2.10:80
   - Destination: 55.66.1.1:50001

2. **Lookup:** B searches NAT table for 55.66.1.1:50001
   - Finds mapping to 192.168.0.10:4000

3. **Translate:** B modifies packet header
   - New Destination IP: 192.168.0.10
   - New Destination Port: 4000
   - Recalculates checksums

4. **Forward:** B sends packet to A on internal network

### ii) IPv4 Packet and Routing Process

**Original Packet from A:**

| Field | Value |
|-------|-------|
| Version | 4 |
| IHL | 5 (20 bytes) |
| TTL | 64 |
| Protocol | 6 (TCP) |
| Source IP | 192.168.0.10 |
| Destination IP | 55.66.2.10 |
| Source Port | 4000 |
| Destination Port | 80 |

**Routing at Each Hop:**

**Node A:**
- Destination 55.66.2.10 not on 192.168.0.0/24
- Consult routing table → default gateway 192.168.0.1 (B)
- Forward to B

**Node B (NAT + Router):**
- Perform NAT translation (source becomes 55.66.1.1:50001)
- Destination 55.66.2.10 → next hop C (55.66.1.2)
- Decrement TTL to 63
- Forward to C

**Node C (Router):**
- Destination 55.66.2.10 → next hop D (55.66.2.1)
- Decrement TTL to 62
- Forward to D

**Node D (Router):**
- Destination 55.66.2.10 is on directly connected network
- Decrement TTL to 61
- Forward directly to E

### iii) Link Layer Frames and ARP

**Hop 1: A → B**

ARP Resolution:
- A needs MAC for 192.168.0.1 (gateway)
- A broadcasts: "Who has 192.168.0.1?"
- B responds: "192.168.0.1 is at BB:BB:BB:BB:BB:01"

Ethernet Frame:
```
| Dest MAC          | Source MAC        | Type   | IP Packet                    | FCS |
| BB:BB:BB:BB:BB:01 | AA:AA:AA:AA:AA:AA | 0x0800 | 192.168.0.10 → 55.66.2.10    | ... |
```

**Hop 2: B → C**

After NAT, B needs MAC for 55.66.1.2:
- B: "Who has 55.66.1.2?"
- C: "55.66.1.2 is at CC:CC:CC:CC:CC:01"

Ethernet Frame:
```
| Dest MAC          | Source MAC        | Type   | IP Packet                  | FCS |
| CC:CC:CC:CC:CC:01 | BB:BB:BB:BB:BB:02 | 0x0800 | 55.66.1.1 → 55.66.2.10     | ... |
```

**Hop 3: C → D**

C needs MAC for 55.66.2.1:
- ARP request/response for D

Ethernet Frame:
```
| Dest MAC          | Source MAC        | Type   | IP Packet                  | FCS |
| DD:DD:DD:DD:DD:01 | CC:CC:CC:CC:CC:02 | 0x0800 | 55.66.1.1 → 55.66.2.10     | ... |
```

**Hop 4: D → E**

D needs MAC for 55.66.2.10:
- ARP request/response for E

Ethernet Frame:
```
| Dest MAC          | Source MAC        | Type   | IP Packet                  | FCS |
| EE:EE:EE:EE:EE:EE | DD:DD:DD:DD:DD:02 | 0x0800 | 55.66.1.1 → 55.66.2.10     | ... |
```

**Key Observation:** IP addresses (after NAT) remain constant end-to-end, while MAC addresses change at every hop.

---

## Part b) Distance Vector and Link State Routing [25 marks]

### i) Description and Comparison

**Distance Vector Routing:**
Each router maintains a table containing the distance (cost/metric) to every known destination and the next-hop router to reach that destination. Routers periodically exchange their complete routing tables with directly connected neighbors. Upon receiving a neighbor's table, a router updates its own entries if a shorter path is discovered using the Bellman-Ford equation: D(x,y) = min[c(x,v) + D(v,y)] for all neighbors v.

**Link State Routing:**
Each router independently discovers its neighbors and measures the cost to reach them. This information is flooded throughout the network as Link State Advertisements (LSAs). Once every router has the complete topology database, each runs Dijkstra's shortest-path algorithm locally to compute optimal routes to all destinations.

**Key Differences:**

| Aspect | Distance Vector | Link State |
|--------|-----------------|------------|
| Information shared | Routing table (distances) | Topology (links) |
| Knowledge | Routes only | Complete map |
| Algorithm location | Distributed | Local |
| Convergence | Slower | Faster |
| Loop prevention | Prone to loops | Loop-free |
| Bandwidth usage | Periodic full tables | Event-driven LSAs |
| Memory | O(N) per router | O(N²) topology |
| Examples | RIP, IGRP | OSPF, IS-IS |

### ii) Distance Vector Routing at TCD (15 Schools)

**Example Topology (subset of 15 schools):**

```
        [CSS]----2----[EE]----3----[Physics]
          |            |              |
          1            4              2
          |            |              |
       [Math]----3---[Chem]----1----[Bio]
          |            |              |
          2            5              3
          |            |              |
      [Stats]---4---[Genetics]--2--[Medicine]
```

**Initial State (t=0):**
Each router knows only directly connected neighbors.

**CSS Initial Table:**
| Destination | Cost | Next Hop |
|-------------|------|----------|
| CSS | 0 | - |
| EE | 2 | EE |
| Math | 1 | Math |

**After Exchange Round 1:**
CSS receives tables from EE and Math.

From EE: "Physics=3, Chem=4"
From Math: "Stats=2, Chem=3"

CSS calculates:
- Physics via EE: 2 + 3 = 5
- Chem via EE: 2 + 4 = 6
- Chem via Math: 1 + 3 = 4 ← Better!
- Stats via Math: 1 + 2 = 3

**CSS Updated Table:**
| Destination | Cost | Next Hop |
|-------------|------|----------|
| CSS | 0 | - |
| EE | 2 | EE |
| Math | 1 | Math |
| Physics | 5 | EE |
| Chem | 4 | Math |
| Stats | 3 | Math |

**Convergence Visualization:**
```
Round 0: Each router knows direct neighbors only
         CSS knows: EE(2), Math(1)
         EE knows: CSS(2), Physics(3), Chem(4)
         
Round 1: Exchange tables with neighbors
         CSS learns: Physics(5), Chem(4), Stats(3)
         
Round 2: Further propagation
         CSS learns: Bio, Genetics via multi-hop paths
         
Round N: All routers have consistent tables
         Network has converged
```

### iii) Count to Infinity Problem

**Scenario at TCD Network:**

Consider this portion of the network:
```
[CSS]----2----[EE]----4----[Chem]
```

Initially:
- CSS reaches Chem via EE with cost 6 (2+4)
- EE reaches Chem directly with cost 4

**The Link EE-Chem Fails:**

```
[CSS]----2----[EE]    X    [Chem]
```

**What Should Happen:**
- EE should mark Chem as unreachable
- CSS should eventually learn Chem is unreachable

**What Actually Happens (Count to Infinity):**

1. **Before failure:**
   - CSS table: Chem = 6 via EE
   - EE table: Chem = 4 direct

2. **Link fails:** EE detects failure, marks Chem as ∞ (unreachable)

3. **CSS sends update to EE:** "I can reach Chem in 6 hops"

4. **EE updates:** "CSS says 6, plus 2 to CSS = 8. Better than ∞!"
   - EE table: Chem = 8 via CSS

5. **EE sends update to CSS:** "Chem is now 8 away"

6. **CSS updates:** "EE says 8, plus 2 = 10"
   - CSS table: Chem = 10 via EE

7. **This continues:**
   - CSS: 12, 14, 16, 18...
   - EE: 14, 16, 18, 20...

8. **Routing loop forms:** Packets for Chem bounce between CSS and EE

9. **Eventually:** Counters reach "infinity" (e.g., 16 in RIP) and Chem is marked unreachable

**The Problem:** Neither router realizes the other's path goes through itself.

**Solutions:**

- **Split Horizon:** Don't advertise a route back to the neighbor you learned it from
- **Poison Reverse:** Advertise routes learned from a neighbor back with infinite cost
- **Hold-down Timers:** Don't accept new routes to recently-failed destinations
- **Triggered Updates:** Send updates immediately on change, don't wait for timer
- **Maximum Hop Count:** Define infinity as small number (16) to limit damage

---

*End of December 2022 Exam Answers*
